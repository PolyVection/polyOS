#!/bin/bash

#-------------------------------------------------------------------------------
# Use this script to run Yocto builds through Jenkins.  It is expected that the
# top level repo is a git supermodule, with poky and jenkins-yocto-tools as
# submodules.  To build, set up a multi-configuration project that at least
# sets up one user-defined axis: TARGET.  TARGET is the package, image, or
# whatever else you're wanting to build.
#
# If you want to keep the output of the build, then configure Jenkins to
# archive the contents of the "artifacts" directory.
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# Constants
#-------------------------------------------------------------------------------
sstate_dir="sstate-mirror:/bonus/scratch/sstate-mirror"

lockfile=$(mktemp $WORKSPACE/lock-XXXX)
echo $$ > $lockfile
if ! ln $lockfile $WORKSPACE/LOCK; then
	echo "Workspace already in use!  Confirm that your custom workspace path matches your project name in jenkins!"
	cat $PWD/LOCK
	ps $(cat $PWD/LOCK)
	rm $lockfile
	exit 1
fi

#-------------------------------------------------------------------------------
# cleanup() removes any temporary files/directories generated by this script.
# We run it under a trap so we'll remove files whenever we exit.
#-------------------------------------------------------------------------------

cleanup()
{
    rc="$?"
    echo "Cleaning up..."
    if [ -n "$BUILD_PID" ]; then
	    kill -9 $BUILD_PID
	    wait $BUILD_PID
	    BUILD_PID=""
    fi
    if [ -n "$TAIL_PID" ]; then
	    kill $TAIL_PID
	    TAIL_PID=""
    fi
    rm -f $WORKSPACE/LOCK
    if [ -n "$SSH_AGENT_PID" ]; then
	    kill $SSH_AGENT_PID
	    SSH_AGENT_PID=""
    fi
    exit "$rc"
}

trap cleanup EXIT INT TERM


#-------------------------------------------------------------------------------
# usage()
#-------------------------------------------------------------------------------

usage()
{
    cat <<EOF

Usage: $0 [options]

Runs a Yocto build in Jenkins.  Note that the TARGET environment
variable *must* be set for this script to work correctly.  These variables
inform Yocto what package or image to build for which machine.  Normally they
are set by an axis in a multi-configuration project.

Options:

  -a <pkgs>  : Comma-separated packages to build using AUTOREV as the SRCREV.

  -h         :  This usage message.

EOF
    exit 1
}


#-------------------------------------------------------------------------------
# Die if TARGET isn't set.
#-------------------------------------------------------------------------------

while getopts 'a:hrv' opt
do
  case $opt in
      a) autorev="-a $OPTARG";;
      h) usage;;
      *) usage;;
  esac
done

if [ -z "$TARGET" ]
then
    echo "FATAL: Couldn't get the TARGET variable from the environment."
    echo "Either you didn't set up a user-defined axis for TARGET or it's empty."
    exit 3
fi

if [ -z "$BUILD_NUMBER" ]
then
    echo "FATAL: Couldn't get the BUILD_NUMBER variable from the environment."
    echo "Are you *really* running this from Jenkins?  It should have set that."
    exit 4
fi

if [ -z "$JOB_NAME" ]
then
    echo "FATAL: Couldn't get the JOB_NAME variable from the environment."
    echo "Are you *really* running this from Jenkins?  It should have set that."
    exit 5
fi

export ARTIFACTS=${WORKSPACE}/artifacts

if [ -e "$ARTIFACTS" ]; then
	rm -rf "$ARTIFACTS"
fi
mkdir $ARTIFACTS

export LOGFILE=$ARTIFACTS/build-output.log

# Jenkins builds do not have an ssh-agent.  Start one
eval `ssh-agent`

if [ -d poky/build ]; then
	echo "NOTE: reused existing workspace!"
fi

${WORKSPACE}/sources/meta-polyos/scripts/bitbake-polyos.sh -c -t "$TARGET" -i $sstate_dir $autorev > $LOGFILE &

# Certain versions of Jenkins get mad if you output too much to the
# console, with the symptom that your SSH slave gets randomly
# disconnected.  bitbake can spew out quite a bit very quickly, so we'll
# just periodically sample from the logfile instead.  The entire output
# will be shown after the build.
BUILD_PID="$!"
(
	while true; do
		tail -n 1 $LOGFILE
		sleep 10
	done
) &
TAIL_PID="$!"
wait $BUILD_PID
build_status=$?
kill $TAIL_PID
BUILD_PID=""
TAIL_PID=""

echo
echo "Entire build output:"
echo
cat $LOGFILE

mv $WORKSPACE/*.log "$ARTIFACTS"

if [ -e poky/build/fail.tgz ]; then
	mv poky/build/fail.tgz $ARTIFACTS
fi

if [ -d poky/build/tmp/work ]; then
	cd poky/build/tmp/work
	(find . -path "./*/*/temp/*"; find ./*/*/*/build -name "*.log") | tar -zcf $ARTIFACTS/logs.tgz -T -
	cd -
fi

# Poky 1.5 adds $MACHINE to the path under images. Search in "images" and subdirs
for dir in `find poky/build/tmp/deploy/images -maxdepth 1 -type d 2>/dev/null`; do
	cd $dir
        mv core-image* "$ARTIFACTS"
        cp bzImage* "$ARTIFACTS"
	cd -
done

if [ -d poky/build/tmp/deploy/sdk ]; then
        cd poky/build/tmp/deploy/sdk
        mv *.sh "$ARTIFACTS"
        cd -
fi

if [ -d poky/build/tmp/stamps ]; then
        cd poky/build/tmp/stamps
	tar -zcf "$ARTIFACTS"/stamps.tgz *
        cd -
fi

# Symlinks are pointless and cause jenkins to use extra space
find "$ARTIFACTS" -type l -exec rm \{} \;

# Publish SHA1SUMS of the artifacts
# For verification, it is important to cd to directory the files are in
cd "$ARTIFACTS" && sha1sum * > SHA1SUMS

exit $build_status
