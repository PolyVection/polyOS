#!/bin/bash

#-------------------------------------------------------------------------------
# cleanup() removes any temporary files/directories generated by this script.
# We run it under a trap so we'll remove files whenever we exit.
#-------------------------------------------------------------------------------

cleanup()
{
    rc="$?"
    echo "Cleaning up..."
    if [ -n "$BUILD_PID" ]; then
	    kill -9 $BUILD_PID
	    wait $BUILD_PID
	    BUILD_PID=""
    fi
    if [ -n "$TAIL_PID" ]; then
	    kill $TAIL_PID
	    TAIL_PID=""
    fi
    rm -f $WORKSPACE/LOCK
    if [ -n "$SSH_AGENT_PID" ]; then
	    kill $SSH_AGENT_PID
	    SSH_AGENT_PID=""
    fi
    exit "$rc"
}

trap cleanup EXIT INT TERM


#-------------------------------------------------------------------------------
# usage()
#-------------------------------------------------------------------------------

usage()
{
    cat <<EOF

Usage: $0 [options]

Runs a Yocto build in Jenkins.  Note that the TARGET environment
variable *must* be set for this script to work correctly.  These variables
inform Yocto what package or image to build for which machine.  Normally they
are set by an axis in a multi-configuration project.

Options:

  -a <pkgs>  : Comma-separated packages to build using AUTOREV as the SRCREV.

  -h         :  This usage message.

EOF
    exit 1
}


#-------------------------------------------------------------------------------
# Die if TARGET isn't set.
#-------------------------------------------------------------------------------

while getopts 'a:hrv' opt
do
  case $opt in
      a) autorev="-a $OPTARG";;
      h) usage;;
      *) usage;;
  esac
done

if [ -z "$TARGET" ]
then
    echo "FATAL: Couldn't get the TARGET variable from the environment."
    echo "Either you didn't set up a user-defined axis for TARGET or it's empty."
    exit 3
fi

if [ -z "$BUILD_NUMBER" ]
then
    echo "FATAL: Couldn't get the BUILD_NUMBER variable from the environment."
    echo "Are you *really* running this from Jenkins?  It should have set that."
    exit 4
fi

if [ -z "$JOB_NAME" ]
then
    echo "FATAL: Couldn't get the JOB_NAME variable from the environment."
    echo "Are you *really* running this from Jenkins?  It should have set that."
    exit 5
fi

export ARTIFACTS=${WORKSPACE}/artifacts

if [ -e "$ARTIFACTS" ]; then
	rm -rf "$ARTIFACTS"
fi
mkdir $ARTIFACTS

export LOGFILE=$ARTIFACTS/build-output.log

# Jenkins builds do not have an ssh-agent.  Start one
eval `ssh-agent`

if [ -d poky/build ]; then
	echo "NOTE: reused existing workspace!"
fi

${WORKSPACE}/sources/meta-polyos/scripts/bitbake-polyos.sh -c -t "$TARGET" -i $sstate_dir $autorev > $LOGFILE &

# Certain versions of Jenkins get mad if you output too much to the
# console, with the symptom that your SSH slave gets randomly
# disconnected.  bitbake can spew out quite a bit very quickly, so we'll
# just periodically sample from the logfile instead.  The entire output
# will be shown after the build.
BUILD_PID="$!"
(
	while true; do
		tail -n 1 $LOGFILE
		sleep 10
	done
) &
TAIL_PID="$!"
wait $BUILD_PID
build_status=$?
kill $TAIL_PID
BUILD_PID=""
TAIL_PID=""

echo
echo "Entire build output:"
echo
cat $LOGFILE
echo "jenkins-bitbake EXIT CODE = $build_status"
exit $build_status
